package aed;

// Todos los tipos de datos "Comparables" tienen el mÃ©todo compareTo()
// elem1.compareTo(elem2) devuelve un entero. Si es mayor a 0, entonces elem1 > elem2
public class ABB<T extends Comparable<T>> implements Conjunto<T> {
    
    private Nodo _raiz;
    private int _cardinal;
    private int _altura;

    private class Nodo {
        T valor;
        Nodo izq;
        Nodo der;
        Nodo arriba;
        Nodo(T v){
            valor = v;
            izq = null;
            der = null;
            arriba = null;
        }
    }

    public ABB() {
        _raiz = null;
        _cardinal = 0;
        _altura=0;
    }

    public int cardinal() {
        return _cardinal;
        
    }
    
    public T minimo(){
        Nodo nodo = _raiz;
        Nodo arriba = null;

        while (nodo != null){
            arriba = nodo;
            nodo = nodo.izq; 
        }
        return arriba.valor;
    }

    public T maximo(){
        Nodo nodo = _raiz;
        Nodo arriba = null;

        while (nodo != null){
            arriba = nodo;
            nodo = nodo.der;
        }
        return arriba.valor;
    }

    // ok 
    public void insertar(T elem){
        Nodo nuevo = new Nodo(elem);
        Nodo nodo = _raiz;

        if(!pertenece(elem)){
            if(_raiz == null){ 
                _raiz = nuevo;
            }else{ 
              
                int k = elem.compareTo(nodo.valor);

                while(nodo != null){ // elem != nodo
                    k = elem.compareTo(nodo.valor); 
                    nodo.arriba = nodo; // nodo previo
    
                    // actualizo nodo
                    if(k<0){ // elem < nodo
                        if (nodo.izq != null){
                           nodo = nodo.izq; // sigo
                        }else{ // nodo.izq = null
                            nodo.izq = nuevo; // inserto nuevo
                            nodo = nodo.izq;  // nodo = elem
                            break;
                        }  
                    }else{   // elem > nodo
                        if (nodo.der != null){
                            nodo = nodo.der; // sigo
                        }else{ // nodo.der = null
                            nodo.der = nuevo; // inserto nuevo
                            nodo = nodo.der;  // nodo = elem
                            break;
                        }    
                    }
                }
            } 
            _cardinal++;    
        }
        
        
        
    }


    public boolean pertenece(T elem){
        Nodo nodo = _raiz;
        int k;

        while (nodo != null) {

           k = elem.compareTo(nodo.valor);
           if(k==0){ // elem = nodo
             return true;
           }
           nodo.arriba = nodo; // nodo previo.
           if(k<0){ // elem < nodo
              nodo = nodo.izq;
            }else{  // elem > nodo
              nodo = nodo.der;
            }
        }
        return false;
    }




    public void eliminar(T elem){
        Nodo nodo = _raiz;
        int k = elem.compareTo(nodo.valor);

        if (pertenece(elem)){

            // busco nodo = elem
            while(k != 0){ // elem != nodo
                k = elem.compareTo(nodo.valor);
                nodo.arriba = nodo; // nodo previo
                if (k < 0){
                    nodo = nodo.der;
                }else{
                    nodo= nodo.izq;
                }
            // nodo = elem  
            // previo --> nodo.arriba 

            // no tiene desendencia
            if(nodo.der == null && nodo.izq == null){
                 
                nodo = nodo.arriba; // padre de elem
                int q = elem.compareTo(nodo.izq.valor);
                if (q == 0){// padre.izq = elem 
                   nodo.izq = null; // elimino
                }else{      //   padre.der = elem 
                   nodo.der = null; // elimino
                }
            }
            // tiene un solo hijo
            if(nodo.der!=null ^  nodo.izq!=null){

                if(nodo.der != null){ // tiene hijo derecho, elem.der

                    nodo = nodo.arriba; // ahora esto en padre de elem
                    int q = elem.compareTo(nodo.izq.valor);
                    // nodo = padre de elem 

                    // elem es hijo der o izq de nodo (padre) ?
                    // reemplazo elem por su hijo derecho
                    if (q == 0){// nodo.izq = elem 
                        nodo.izq = nodo.izq.der; // nodo.izq = elem.der
                    }    
                    // reemplazo elem por su hijo derecho
                    else {  // nodo.der = elem 
                        nodo.der = nodo.der.der ; // nodo.der = elem.der
                    }    
                }else{ // tiene hijo izquierdo, elem.izq

                    nodo = nodo.arriba; // ahora estoy en padre de elem
                    int q = elem.compareTo(nodo.izq.valor);

                    // nodo = padre de elem 

                    // elem es hijo der o izq de nodo (padre)?
                    // reemplazo elem por su hijo izquierdo
                    if (q == 0){// nodo.izq = elem 
                        nodo.izq = nodo.izq.izq;  // nodo.izq = elem.izq
                    }    
                    // reemplazo elem por su hijo izquierdo
                    else {  // nodo.der = elem 
                        nodo.der = nodo.der.izq;  // nodo.der = elem.izq ;
                    }    
                }
            }
            // tiene dos hijos
            if(nodo.der != null && nodo.izq != null){
               // busco sucesor
                if(nodo.der != null){ // tiene subarbol derecho
                    nodo = nodo.der;
                    while (nodo.izq != null){
                        nodo = nodo.izq;
                    } // nodo = minimo.izq
                }else{
                  padre = nodo.arriba;
                  while (padre != null && nodo == padre.right){
                       nodo = padre;
                       padre = padre.arriba 
                  }
                }  
            }
          }
       }
    }


    // Aux Fucktions

    public boolean perteneceRecursivo(Nodo nodo, T elem){
    
        if(nodo == null){
            return false;
        }else{
            int k = elem.compareTo(nodo.valor);  
            // elem == nodo.valor
            if(k == 0){
                return true;    
            }
            // elem < nodo.valor
            if(k < 0){
                nodo.arriba = nodo;
                nodo = nodo.izq;  
                return perteneceRecursivo(nodo, elem);      
            }else{
                nodo.arriba = nodo;
                nodo = nodo.der;   
                return perteneceRecursivo(nodo, elem);
            }

        }        
    }

    public Nodo sucesor(Nodo nodo){
       if(nodo != null){ 
            while (nodo.der != null){
                nodo.arriba = nodo;
                nodo = nodo.der; 
            }
            return nodo ;
       }
       Nodo padre = nodo.arriba; 
       while (padre != null && nodo == padre.der ) {
           nodo = padre;
           padre = nodo.arriba;
       } 
       return padre;
    }

    public Nodo buscarNodo(Nodo nodo, T elem){
        int k = elem.compareTo(nodo.valor);
        while(nodo != null && k != 0){
            nodo.arriba = nodo;
            if (k < 0){
                nodo = nodo.der;
            }else{
                nodo= nodo.izq;
            }
        }return nodo;
    }


    //

    public String toString(){
        throw new UnsupportedOperationException("No implementada aun");
    }

    private class ABB_Iterador implements Iterador<T> {
        private Nodo _actual = minimo();
        
        
        public boolean haySiguiente() { 
            int k = _actual.valor.compareTo(_raiz.valor) 

            if(k >= 0){ // actual >= valor
               return _actual.der != null;
            } 
            else {    // _actual < raiz
               return _actual.arriba != null;
            }
        }
    
        public T siguiente() {
            int k = _actual.valor.compareTo(_raiz.valor) 
            if(k >= 0){ // actual >= valor
               int siguiente = actual.valor;
               actual = _actual.der;
               return siguiente;
            } 
            else {    // _actual < raiz
               int siguiente = _actual.valor; 
               actual = actual.arriba;
               return siguiente;
            }
        }
    }

    public Iterador<T> iterador() {
        return new ABB_Iterador();
    }

}
